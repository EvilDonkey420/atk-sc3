title:: ABCs of the ATK
summary:: Ambisonic Toolkit, a library for research, analysis, synthesis and composition
categories:: Libraries>Ambisonic Toolkit
keyword::Atk

section:: The paradigm

The Ambisonic Toolkit (ATK) brings together a number of classic and novel tools and transforms for the artist working with Ambisonic surround sound and makes these available to the SuperCollider user. The toolset in intended to be both ergonomic and comprehensive, and is framed so that the user is encouraged to ‘think Ambisonically’. By this, it is meant the ATK addresses the holistic problem of creatively controlling a complete soundfield, allowing and encouraging the artist to think beyond the placement of sounds in a sound-space (sound-scene paradigm). Instead the artist is encouraged to attend to the impression and imaging of a soundfield, therefore taking advantage of the native soundfield-kernel paradigm the Ambisonic technique presents.

The ATK's production model is illustrated below:

image::atknetwork.png#ATK paradigm::

Here you'll see that the ATK breaks down the task of working with Ambisonics into three separate elements:

definitionlist::
## Author || Capture or synthesise an Ambisonic soundfield.
## Image || Spatially filter an Ambisonic soundfield.
## Monitor || Playback or render an Ambisonic soundfield.
::

subsection:: Features

Some notable features of the ATK include:

list::
## Integrated support for classic strong::First Order Ambisonics (FOA):: and modern strong::Higher Order Ambisonics (HOA)::.
## Implements the emphasis::Nearfield Controlled::, aka emphasis::Nearfield Compensated::, form of Higher Order Ambisonics (NFC-HOA).
## Ambisonic order is merely limited by system speed, channel capacity and numerical precision rather than by design. footnote::Caveat: link::Tutorials/ATK-FAQs#What%20is%20the%20highest%20order%20supported%20for%20spherical%20decomposition?#What is the highest order supported for spherical decomposition?:: ::
## Control and synthesis of the nearfield effect of finite distance sources in both FOA and HOA.
## Comprehensive FOA soundfield analysis in instantaneous and time averaged forms.
## Ambisonic coefficients and matrices are available for inspection and manipulation in the interperter.
## Angular domain soundfield decomposition and recomposition.
## Analysis of transformer and decoder matrices.
::


section:: Installation

strong::Instructions:: for installing the complete system are found link::https://github.com/ambisonictoolkit/atk-sc3/blob/master/README.md#installing#here::. (<-- click link!)

If you're reading this document at least emphasis::one:: part of the ATK, the link::https://github.com/ambisonictoolkit/atk-sc3##atk-sc3 quark:: has most likely been corectly installed.


note::
If the link::Classes/HelpBrowser:: doesn't navigate to the section of the quark README titled
strong::Installing::, just search link::https://github.com/ambisonictoolkit/atk-sc3/blob/master/README.md#installing#the page:: to find.
::

subsection:: Components

The complete ATK library is built from of a number of components. These are:

list::
## link::Guides/WritingUGens#Pseudo-UGens#pseudo-UGens::, classes, extension methods and documentation found in the link::https://github.com/ambisonictoolkit/atk-sc3##atk-sc3 quark::
## ATK UGens found in link::https://github.com/supercollider/sc3-plugins/releases##sc3-plugins::
## link::http://www.ambisonictoolkit.net/download/kernels/##kernels::, link::http://www.ambisonictoolkit.net/download/matrices/##matrices:: & link::http://www.ambisonictoolkit.net/download/recordings/##soundfiles:: found in the link::https://github.com/ambisonictoolkit##ATK repository::
::

note::
All of these components, except for the link::http://www.ambisonictoolkit.net/download/recordings/##soundfiles:: are required!
::

If you've successfully completed the steps described link::#Installation#above::, you should have a working installation of the ATK.

We can easily inspect the strong::quark:: and installed quark dependencies via the link::Classes/QuarksGui:::

code::
QuarksGui.new
::

Though we already know the answer, we can also run this test:

code::
(
("The ATK quark component % installed!").format(
	Quarks.isInstalled("atk-sc3").if({
		"is"
	}, {
		"isn't"
	})
).postln
)
::

If the strong::quark:: has been installed in code::Quarks.folder::, we can poke about:

code::
(Quarks.folder +/+ "atk-sc3").openOS
::

Similarly, if the UGens found in strong::sc3-plugins:: have been installed in code::Platform.userExtensionDir:::

code::
(Platform.userExtensionDir +/+ "SC3plugins/ATK").openOS
::

And, if the strong::kernels::, strong::matrices:: and strong::soundfiles:: have
been installed in each related user directories, we can inspect:

code::
(
Atk.userKernelDir.openOS;
Atk.userMatrixDir.openOS;
Atk.userSoundsDir.openOS;
)
::


section:: Suggested extensions

Users can expand the functionality of the ATK by adding additional extensions. The following are suggested.

subsection:: ADT

The link::https://gitlab.com/dxarts/projects/adt.quark##ADT quark:: offers a convenient interface to the link::https://bitbucket.org/ambidecodertoolbox/adt/src/master/##Ambisonic Decoder Toolbox::, a collection functions for creating Ambisonic Decoders. The interface supplied by the quark has been designed to facilitate use with the ATK.

At the time of this writing, the link::https://gitlab.com/dxarts/projects/adt.quark##ADT quark:: has not yet been included the SuperCollider link::https://github.com/supercollider-quarks/quarks/blob/master/directory.txt##Quark directory::, meaning that the link::Classes/QuarksGui:: cannot be used to install.

You can install the quark:

code::
Quarks.install("https://gitlab.com/dxarts/projects/adt.quark")
::

You'll then need to complete the installation by installing link::https://bitbucket.org/ambidecodertoolbox/adt/src/master/##Ambisonic Decoder Toolbox:: library and link::https://www.gnu.org/software/octave/##Octave::.

Follow the instructions found link::https://gitlab.com/dxarts/projects/adt.quark#adt#here::.


subsection:: AmbiVerbSc

Everyone loves reverb! Built on the ATK, the link::https://github.com/JamesWenlock/AmbiVerbSC##AmbiVerbSc quark:: provides a native first order Ambisonic tank style reverb algorithm.

As with the link::https://gitlab.com/dxarts/projects/adt.quark##ADT quark::, the link::https://github.com/JamesWenlock/AmbiVerbSC##AmbiVerbSc quark:: has not yet been included the SuperCollider link::https://github.com/supercollider-quarks/quarks/blob/master/directory.txt##Quark directory::.

To install the quark:

code::
Quarks.install("https://github.com/JamesWenlock/AmbiVerbSC")
::



section:: Related packages

Support for Ambisonics within SuperCollider has existed in a variety of forms over the years. The principal form of this support has been via link::Guides/UGens-and-Synths##unit generators:: supplied for emphasis::monophonic source:: Ambisonic encoding footnote::I would describe this as panning, or emphasis::basic:: encoding.:: and two dimensional, aka emphasis::pantophonic::, decoding.

Over the years, a number of related but different emphasis::Ambisonic encoding formats:: have been used. (These formats will be discussed in more detail, link::#Encoding%20formats#below::.) For now, the thing to keep in mind is that when we use tools from multiple packages, we need to be sure to correctly exchange Ambisonic encoding formats where these differ.

When you've fully completed the link::#Installation#installation:: of the ATK, you'll automagically also have two other packages installed, the link::#SuperCollider#SuperCollider builtins:: footnote::Actually, already include as part of SuperCollider.:: and those found in link::#JoshUGens::. The other two, link::#AmbIEM:: and link::#SC-HOA:: require additional steps.

For ease of comparison, the UGens supplied by each package are listed according to the ATK's link::#Ambisonic UGens#UGen classification convention::. (In this text we'll refer to a particular Ambisonic UGen as a strong::type:: of Ambisonic UGen.)

Any additional utitilities or functionality supplied by these packages are not discussed here.

note::
At the time of this writing, ATK namespace collisions with the four packages listed here emphasis::have not:: been observed. In other words, it emphasis::should:: be possible to configure a system with all the below installed.

If at some point you find a collision with the below packages (or any other), please let us know: link::Tutorials/ATK-FAQs#How%20do%20I%20report%20a%20bug?#How do I report a bug?::
::


subsection:: SuperCollider

The original author of SuperCollider has provided basic support for first order Ambisonics (FOA) via the following unit generators:

definitionlist::
## Encoder || link::Classes/PanB::, link::Classes/PanB2::, link::Classes/BiPanB2::
## Transformer || link::Classes/Rotate2::
## Decoder || link::Classes/DecodeB2::
::

Many SuperCollider users have been introduced to Ambisonics through experimentation
with these UGens.

(Follow link::#SCEncodingFormat#this link:: to review SuperCollider's encoding format.)


subsection:: JoshUGens

As with the ATK, the link::https://github.com/supercollider/sc3-plugins/tree/master/source/JoshUGens##JoshUGens:: collection is also distributed via link::https://github.com/supercollider/sc3-plugins/releases##sc3-plugins::, and offers further implementations in first and second order Ambisonic forms.

The following unit generators are supplied:

definitionlist::
## Encoder || link::Classes/BFEncode::, link::Classes/BFEncode1::, link::Classes/BFEncode2::, link::Classes/BFEncodeSter::, link::Classes/FMHEncode0::, link::Classes/FMHEncode1::, link::Classes/FMHEncode2::, link::Classes/A2B::, link::Classes/UHJ2B::, link::Classes/UHJtoB::
## Transformer || link::Classes/BFManipulate::, link::Classes/Rotate::, link::Classes/Tilt::, link::Classes/Tumble::
## Decoder || link::Classes/BFDecode::, link::Classes/BFDecode1::, link::Classes/FMHDecode1::, link::Classes/B2Ster::, link::Classes/B2A::, link::Classes/B2UHJ::, link::Classes/BtoUHJ::
## Effect || link::Classes/BFFreeVerb::, link::Classes/BFGVerb::
::

One of the authors of the link::https://github.com/supercollider/sc3-plugins/tree/master/source/JoshUGens##JoshUGens:: package is a significant contributor to the ATK.

(Follow link::#JoshUGensEncodingFormat#this link:: to review JoshUGens's encoding format.)

note::
The authors consider it appropriate to regard the functionality provided by corresponding link::Guides/WritingUGens#Pseudo-UGens#pseudo-UGens:: and UGens found in strong::JoshUGens:: to be superceeded by the ATK.

I.e., rather than using strong::JoshUGens:: link::Classes/B2UHJ:: (or link::Classes/BtoUHJ::), users should rely upon the ATK's UHJ implementation, link::Classes/FoaDecoderKernel#*newUHJ::.
::


subsection:: AmbIEM

The link::https://sonenvir.at/downloads/sc3/ambiem/##AmbIEM library:: is distributed via the link::https://github.com/supercollider-quarks/AmbIEM##AmbIEM quark::, and offers support for first, second and third order Ambisonics.

If you've installed this quark you can search for the link::search#AmbIEM#AmbIEM:: overview page, or navigate to the library's distributed link::Browse#Libraries>AmbIEM#Help::.

AmbIEM supplies the following unit generators:

definitionlist::
## Encoder || PanAmbi1O, PanAmbi2O, PanAmbi3O
## Transformer || RotateAmbi1O, RotateAmbi2O, RotateAmbi3O
## Decoder || DecodeAmbi2O, DecodeAmbi3O, BinAmbi3O
::

(Follow link::#AmbIEMEncodingFormat#this link:: to review AmbIEM's encoding format.)

note::
The kernels required for binaural decoding via BinAmbi30 are not distributed via the link::https://github.com/supercollider-quarks/AmbIEM##AmbIEM quark::.

At the time of this writing, the suggested link::https://github.com/supercollider-quarks/AmbIEM/blob/master/Classes/Binaural.sc#L115#link found in the source code:: appears to be broken.

Instead, the currently live link to this dependency, code::full.tar.Z::, appears to be link::https://sound.media.mit.edu/resources/KEMAR.html##here::.
::


subsection:: SC-HOA

Like the ATK and JoshUGens, the SC-HOA library, aka HOA for SuperCollider, has components distributed via link::https://github.com/supercollider/sc3-plugins/tree/master/source/HOAUGens##sc3-plugins::. Additionally, for a full installation, the link::https://github.com/florian-grond/SC-HOA##SC-HOA quark::, which includes kernel assets, must also be installed. This library provides support for First through Fifth Order Ambisonics.

If you've installed this quark you can search for the link::search#HOA%20Guide#HOA Guide:: overview page, or navigate to the library's distributed link::Browse#Libraries>HOA#Help::. SC-HOA includes tutorials, too, which will be link::search#HOA Tutorial#found here:: if installed.

SC-HOA provides the following footnote::documented or otherwise mentioned intutorials:: user facing unit generators:

definitionlist::
## Encoder || HOAEncoder, HOAmbiPanner, HOALibEnc3D, HOAEncLebedev06, HOAEncLebedev26, HOAEncLebedev50, HOAEncEigenMike, HOAConvert
## Transformer || HOATransRotateAz, HOATransRotateXYZ, HOATransMirror, HOABeamHCard2Hoa, HOABeamDirac2Hoa, HOALibOptim
## Decoder || HOADec5_0, HOABeamHCard2Mono, HOABinaural, Lebedev50BinauralDecoder, HOADecLebedev06, HOADecLebedev26, HOADecLebedev50, HOAConvert
::

(Follow link::#SC-HOAEncodingFormat#this link:: to review SC-HOA's encoding format.)

section:: Ambisonic formats

For users new to the world of Ambisonics, perhaps one of the most confusing aspects is the use of the term emphasis::format::. This confusion is understandable, given how this word has been used differently over time and in different contexts.

One way this word is used is to describe the emphasis::Ambisonic encoding format::, aka the emphasis::encoding convention::, of an Ambisonic signal.

Another use of the word is to describe the emphasis::spatial domain:: of an Ambisonic signal.

subsection:: Encoding formats

If you haven't already, a great place to start with understanding encoding formats is to review this page:

list::
## link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats##Ambisonic data exchange formats::
::

Given an Ambisonic signal, there are four things we need to know for the encoding format (or convention) to be completely specified and unambiguous. These are:

definitionlist::
## Ambisonic order || An integer describing the spatial resolution. Specifies the maximum emphasis::Associated Legendre:: degree, ℓ, of a given signal or coefficient set.

## Ambisonic component ordering || Sorting or ordering convention applied to arrange spherical harmonic encoding coefficients and resulting signal sets. E.g., Furse-Malham (FuMa), Ambisonic Channel Number (ACN), Single Index Designation (SID). See link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#Component_ordering#ordering::.

## Ambisonic component normalisation || emphasis::Spherical harmonic:: coefficient normalisation convention. E.g., maxN, N3D, SN3D. See link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#Normalisation#normalisation::.

## Ambisonic reference radius || Encoding radius where all modal components are real.
::

note::
Of these four quantities, many user facing Ambisonic software packages omit specifying a reference radius. If we would like to successfully synthesize soundfields with controlled nearfield effects (NFE), this value must be known.

The ATK specifies reference radius in meters.
::

The ATK will report these details for the FOA implementation:

code::
AtkFoa.defaultOrder.postln;  // -> 1
AtkFoa.ordering.postln;  // -> fuma
AtkFoa.normalisation.postln;  // -> fuma
AtkFoa.refRadius.postln;  // -> inf
::

The ATK uses the normalisation indicator strong::FuMa:: as a synonym for strong::MaxN:: to indicate Furse-Malham normalisation in the form compatable with classic Gerzonic Ambisonic encoding.

And the HOA implementation:

code::
AtkHoa.defaultOrder.postln;  // -> 3
AtkHoa.ordering.postln;  // -> acn
AtkHoa.normalisation.postln;  // -> n3d
AtkHoa.refRadius.postln;  // -> 1.5
::

The very first, Ambisonic order, directly indicates the number of channels (or coefficients) and encoded signal will have. The math to report looks like:

code::
~order = AtkFoa.defaultOrder;
// ~order = AtkHoa.defaultOrder;

(~order + 1).squared.postln;
::

The HOA implementation offers another way of reporting the number of channels, through a method for link::Classes/HoaOrder:::

code::
~myOrder = 5;  // greater than the default!

~hoaOrder = HoaOrder.new(~myOrder);
~hoaOrder.size.postln;  // -> 36
::

For convenience, the ATK uses the keyword strong::format:: to indicate component ordering and component normalisation, grouped together:

code::
AtkFoa.format.postln;  // -> [ fuma, fuma ]
AtkHoa.format.postln;  // -> [ acn, n3d ]
::

This use of the word format, to specify both ordering and normalisation, is the most common in the era of modern Ambisonics. So, users often speak of a signal being encoded as ACN-N3D or ACN-SN3D, the latter being known as AmbiX.

We can also look up common encoding convention formats:

code::
~myOtherFormat = \ambix;  // AmbiX (Ambisonics exchangeable)
// ~myOtherFormat = \fuma;  // Furse-Malham

AtkHoa.formatDict[~myOtherFormat].postln;
::

The ATK includes another designation, strong::set::, to group all these features together. This can refer to an Ambisonic strong::signal:: or a strong::tool set::. For instance a signal described as strong::HOA5:: is specified as:

anchor::HOA5::
definitionlist::
## strong::HOA5:: ||
list::
## strong::order:: : 5
## strong::ordering:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#ACN#ACN::
## strong::normalisation:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#N3D#N3D::
## strong::reference radius:: : 1.5 meters
::
::

________________

Let's now consider the emphasis::Ambisonic encoding formats:: of the above link::#Related%20packages#related packages:: (package names link to UGen lists, above):

anchor::SCEncodingFormat::
definitionlist::
## link::#SuperCollider:: ||
list::
## strong::order:: : 1
## strong::ordering:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#Furse-Malham#FuMa::
## strong::normalisation:: : FuMa (aka link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#maxN#MaxN::) footnote::
MaxN indicates scaling is the same as classic, aka Gerzonic, first order Ambisonics. From link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#maxN#Wikipedia:::
note::
MaxN is used in the Furse-Malham format (with the exception of a -3dB correction factor for W, which makes it directly compatible with traditional B-Format).
::
::
## strong::reference radius:: : inf footnote::For classic, aka Gerzonic, the reference radius is infinity.::
::
::

anchor::JoshUGensEncodingFormat::
definitionlist::
## link::#JoshUGens:: ||
list::
## strong::order:: : 1, 2
## strong::ordering:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#Furse-Malham#FuMa::
## strong::normalisation:: : FuMa (aka link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#maxN#MaxN::)
## strong::reference radius:: : inf
::
::

anchor::AmbIEMEncodingFormat::
definitionlist::
## link::#AmbIEM:: ||
list::
## strong::order:: : 1, 2, 3
## strong::ordering:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#SID#SID::
## strong::normalisation:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#SN3D#SN3D::
## strong::reference radius:: : inf footnote::Unspecified, presume emphasis::basic encoding:: is emphasis::planewave encoding::. This would mean the reference radius is infinity.::
::
::

anchor::SC-HOAEncodingFormat::
definitionlist::
## link::#SC-HOA:: ||
list::
## strong::order:: : 1, 2, 3, 4, 5
## strong::ordering:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#ACN#ACN::
## strong::normalisation:: : link::https://en.wikipedia.org/wiki/Ambisonic_data_exchange_formats#N3D#N3D::
## strong::reference radius:: : 1.07 meters footnote::This value is listed as the default value for the argument named strong::speaker_radius:: for the UGen HOAEncoder. If the SC-HOA quark is installed installed, see Help document. Or, link::https://github.com/florian-grond/SC-HOA/blob/master/classes/HOAEncoder.sc#L2#source code::. ::
::
::

________________

In reviewing the above, we can note:

definitionlist::
## SuperCollider || Encodes in the ATK's FOA encoding format
## JoshUGens || Encodes first order in the ATK's FOA encoding format, but does not encode in the ATK's HOA encoding format
## AmbIEM || Does not encode in the ATK's HOA encoding format
## SC-HOA || Nearly encodes in the ATK's HOA encoding format
::

As you would expect, the ATK does facilitate emphasis::exchanging:: signals encoded with different conventions, so we can use all these libraries together if we'd like. We just need to take care to translate signals correctly for the given library.

Because the ATK uses the link::#Ambisonic UGens#below naming convention :: to designate Ambisonic operations, we can consider the conversion of an strong::FOA:: signal to strong::HOA1:: in two different, but equivalent, ways:

list::
## emphasis::decode:: strong::FOA:: to strong::HOA1::
## emphasis::encode:: strong::HOA1:: from strong::FOA::
::

Review the practical examples found here:

FORMAT EXCHANGE EXAMPLE


subsection:: Domain formats

In this section we'll discuss emphasis::Ambisonic spatial domain formats::.

link::https://en.wikipedia.org/wiki/File:Spherical_Harmonics_deg5.png::


section:: Library architecture

The help browsing hierarchy is formatted to illustrate the structure of the ATK from a user point of view.


subsection:: Getting Help

Let's briefly review the presented categories. Following the links below will navigate the browser to the places to find relevent documentation. Some of these links will land on splash page overviews which include a brief description of help to be found in that section.

Casually explore the structure of the ATK by taking some time to navigate these links. (Use the browser back button to return to this page.)

definitionlist::
## link::Browse#Libraries>Ambisonic Toolkit#Ambisonic Toolkit:: ||
definitionlist::
## link::Browse#Libraries>Ambisonic Toolkit>ATK Platform & Configuration#ATK Platform & Configuration:: || various ATK system settings and configurations
## link::Overviews/ABCs-ATK-Coeffs##Coefficients & Theory:: || low level ambisonic coefficients and other theory
## link::Overviews/ABCs-Guides-Toots##Guides & Tutorials:: || documents explaining how to use the ATK
## link::Browse#Libraries>Ambisonic Toolkit>Licensing#Licensing:: || licensing documents and notices
## Matrix & Kernel || classes returning matrices and kernels for use with
corresponding link::Guides/WritingUGens#Pseudo-UGens#pseudo-UGens::
definitionlist::
## link::Browse#Libraries>Ambisonic Toolkit>Matrix & Kernel>FOA#FOA:: || emphasis::user facing:: classes for FOA
## link::Browse#Libraries>Ambisonic Toolkit>Matrix & Kernel>HOA#HOA:: || emphasis::user facing:: classes for HOA
## link::Browse#Libraries>Ambisonic Toolkit>Matrix & Kernel>Internals#Internals:: || base classes and other utilities note::only for the curious!::
::
## UGens || UGens and link::Guides/WritingUGens#Pseudo-UGens#pseudo-UGens::
definitionlist::
## FOA || emphasis::user facing:: FOA UGens and link::Guides/WritingUGens#Pseudo-UGens#pseudo-UGens::
definitionlist::
## link::Browse#Libraries>Ambisonic Toolkit>UGens>FOA>Analyzer#Analyzer:: ||
## link::Browse#Libraries>Ambisonic Toolkit>UGens>FOA>Decoder#Decoder:: ||
## link::Browse#Libraries>Ambisonic Toolkit>UGens>FOA>Encoder#Encoder:: ||
## link::Browse#Libraries>Ambisonic Toolkit>UGens>FOA>Transformer#Transformer:: ||
::
## HOA || emphasis::user facing:: HOA UGens and link::Guides/WritingUGens#Pseudo-UGens#pseudo-UGens::
definitionlist::
## link::Browse#Libraries>Ambisonic Toolkit>UGens>HOA>Decoder#Decoder:: ||
## link::Browse#Libraries>Ambisonic Toolkit>UGens>HOA>Encoder#Encoder:: ||
## link::Browse#Libraries>Ambisonic Toolkit>UGens>HOA>Transformer#Transformer:: ||
::
## Internals || base classes and other utilities note::only for the curious!::
definitionlist::
## link::Browse#Libraries>Ambisonic Toolkit>UGens>Internals>FOA#FOA:: ||
## link::Browse#Libraries>Ambisonic Toolkit>UGens>Internals>HOA#HOA:: ||
::
::
## link::Overviews/ABCs-ATK-Utils##Utilities:: || emphasis::user facing:: high level utilities
definitionlist::
## FOA ||
::
::
::

________________

To make finding the ATK's emphasis::help overviews:: convenient, the titles of these pages all begin with teletype::ABCs::.

Try this: link::Search#abcs::


subsection:: Ambisonic UGens

The ATK uses the keyword strong::type:: to designate emphasis::soundfield operations::. UGens implementing these are defined as:

definitionlist::
## Encoder || UGens receiving (or otherwise synthesizing) emphasis::some:: signal, then returning a spherical domain signal encoded in (default) package ambisonic encoding convention
## Transformer || UGens receiving a spherical domain signal encoded in (default) package ambisonic encoding convention, applying ambisonic processing, and then returning a signal encoded in (default) package ambisonic encoding convention
## Decoder || UGens receiving a spherical domain signal encoded in (default) package ambisonic encoding convention, then returning emphasis::some:: signal emphasis::no longer encoded:: in (default) package ambisonic encoding convention
::


subsection:: Matrix & Kernel

As we've seen above, for a complete install the ATK requires the successful installation of all link::#Components#components::, which include strong::matrix:: and strong::kernel:: assests.

In the abstract mathy sense, Ambisonic strong::operations:: can be described as emphasis::Ambisonic soundfield kernel convolutions::. Sounds difficult!

It also sounds like the implementation of these operations will require emphasis::convolution::. If you've been poking around the link::Browse#Libraries>Ambisonic%20Toolkit>UGens>Internals#UGen internals::, you'll have spotted: link::Classes/AtkKernelConv::. This is the little workhorse handling any required convolution.

The observant reader will also have noticed another UGen found in this location: link::Classes/AtkMatrixMix::.

________________

Thankfully, Ambisonic operations can be simplified given two conditions:

numberedlist::
## the operation emphasis::does not:: require complex coefficients footnote::No imaginary numbers!::
## the operation emphasis::is not:: frequency dependent
::

If these two are met, the operation can be simplied as multiply and add, or emphasis::matrix mixing::. In other words, the operation can be represented as a matrix of real numbers.

This makes life much easier! (And, yes, mixing is so important that SuperCollider provides a UGen for the purpose: link::Classes/Mix::.) As an aside, I'll also note that given a hardware mixer with enough channels (and sends and returns), these more simple Ambisonic operations can be implemented. Not necessarily convenient, but possible.

Some things to note, if an ATK Ambisonic operation is implemented as a strong::kernel:: operation, we can expect:

numberedlist::
## the operation emphasis::may:: require complex coefficients
## the operation emphasis::may:: be frequency dependent
## the operation emphasis::does:: require more CPU time
::

A related implication: we'll expect a strong::kernel:: operation to return a more complex sounding outcome than a strong::matrix:: operation.

For example, link::Classes/FoaEncoderKernel#*newSuper::, the ATK's link::https://en.wikipedia.org/wiki/Ambisonic_UHJ_format#Super_stereo#Ambisonic Super Stereo:: strong::kernel:: encoder is usually preferred over link::Classes/FoaEncoderMatrix#*newStereo::, the much more simple strong::matrix:: encoder.

________________

Aside from structuring the architecture, the ATK also uses these two terms to:

numberedlist::
## designate Ambisonic UGens and associated classes
## answer strong::operation:: assets, i.e., the matrix or kernel
## answer strong::operation::
::

Here are a few examples:

code::

// 1) names
HoaDecodeMatrix.postln;  // given an HOA signal and an HoaMatrixDecoder instance, decode
HoaMatrixDecoder.postln;  // answer HoaMatrixDecoder instance required for the above
::
code::
// 2) assets
HoaMatrixDecoder.newPanto(4).matrix.postln;  // answer the matrix
::
code::
// 3) operation
HoaMatrixDecoder.newPanto(4).op.postln;  // the -op message answers...
::


subsection:: Kinds of operations

The ATK uses the keyword strong::kind:: to identify individual named operations.

Let's review a specific class, link::Classes/HoaMatrixDecoder::, as an example. We can return a list of implemented HOA matrix decoders, listing the strong::kinds:: of decoders this class will design:

code::
~decoderClass = HoaMatrixDecoder;

"% class implements:".format(~decoderClass).postln;
~decoderClass.class.dumpInterface;
::

The class methods listed here emphasis::are:: HOA matrix decoder design methods. When we instantiate an instance with one of these methods, we emphasis::design:: a matrix to be used for decoding.

Given an instance, we see that strong::kind:: returns the name of the design method used:

code::
(
~myMatrixDecoder = HoaMatrixDecoder.newPanto(4);  // 4 channel 3rd order decoder

"instance var: %".format("~myMatrixDecoder").postln;
"tool & signal set: %".format(~myMatrixDecoder.set).postln;
"soundfield operation: %".format(~myMatrixDecoder.op).postln;
"soundfield operation type: %".format(~myMatrixDecoder.type).postln;
"soundfield operation kind: %".format(~myMatrixDecoder.kind).postln;
)
::

Or, in here's the same information, but in more natural language:

code::
(
"% is a % channel % % % %".format(
	"~myMatrixDecoder",
	~myMatrixDecoder.numChannels,
	~myMatrixDecoder.set,
	~myMatrixDecoder.kind,
	~myMatrixDecoder.op,
	~myMatrixDecoder.type
).postln
)
::

Of course, if we'd like to review the strong::kinds:: of design methods available, we can also just visit the help page: link::Classes/HoaMatrixDecoder::


subsection:: Static & dynamic operations

In finishing up our review of the structure of the ATK, we'll note that numerous soundfield operations are available in both emphasis::static:: and emphasis::dynamic:: forms.

Compare the available static and dynamic FOA transformers:

list::
## link::Classes/FoaXformerMatrix:: Class Methods: design (matrix) transform operations
## link::Browse#Libraries>Ambisonic Toolkit>UGens>FOA>Transformer#Transformer:: UGens: apply transform operations
::

________________

Let's review a specific case: HOA beam decoding. A emphasis::beam decoder::, or link::https://en.wikipedia.org/wiki/Beamforming##beamformer::, extracts a single emphasis::beam:: from a soundfield. This operation is equivalant to dropping a single virtual microphone to the soundfield and returning the result.

If we link::Browse#Libraries>Ambisonic Toolkit>UGens>HOA>Decoder#browse:: to review the UGens for HOA decoding, we'll see two decoders listed:

definitionlist::
## link::Classes/HoaDecodeDirection:: || Higher Order Ambisonic (HOA) beam decoder
## link::Classes/HoaDecodeMatrix:: || Matrix renderer from the Ambisonic Toolkit (ATK)
::

The first of these, link::Classes/HoaDecodeDirection::, is the ATK's dynamic HOA emphasis::beamformer::. Reviewing the argument list:

code::
HoaDecodeDirection.ar(in, theta, phi, radius, beamShape: 'basic', order)
::

strong::theta::, strong::phi:: and strong::radius:: may all be varied continuously.

Turning to link::Classes/HoaDecodeMatrix::, we see:

code::
HoaDecodeMatrix.ar(in, hoaMatrix)
::

The matrix required as an argument is not continuously variable. We design the matrix once with link::Classes/HoaMatrixDecoder:::

code::
HoaMatrixDecoder.newDirection(theta, phi, beamShape, order)
::

and then pass it to link::Classes/HoaDecodeMatrix::.

Putting this together, the equivalent beamforming use pattern looks like this:

code::
hoaMatrix = HoaMatrixDecoder.newDirection(theta, phi, beamShape, order);
HoaDecodeMatrix.ar(in, hoaMatrix)
::

This differs from the dynamic beamformer, link::Classes/HoaDecodeDirection::, in that strong::theta:: and strong::phi:: are static and fixed at design time, and we're missing strong::radius::.

________________

With a little bit of effort, we could construct a network that emphasis::would:: allow us to modulate strong::theta:: and strong::phi::. And we could regain the radial functionality, too. footnote::We'd need to throw in link::Classes/HoaRTT:: (or link::Classes/HoaYPR::) and link::Classes/HoaNFCtrl::.:: However, given the ATK already supplies a dynamic HOA beamer, there's no point in doing so.

Well then, what is the point of working with link::Classes/HoaMatrix:: subclass instances? In many cases, we don't actually want our matrix to be changing. When decoding for a real loudspeaker array we'll design the decoder just once. footnote::Our fixed single beam example is a special, degenerate, case.:: Another advantage is that we have access to quite a bit of further details for inspection:

list::
## link::Classes/HoaMatrixDecoder#Information::
## link::Classes/HoaMatrixDecoder#Matrix::
## link::Classes/HoaMatrixDecoder#Analysis::
::

note::
This is one of the aspects of the ATK that sets it apart from the above link::#Related packages#related packages::, and allows matrix operations to be viewed as flexible, open boxes  rather than closed box solutions.
::


section:: What next?

link::Guides/ATK-FAQs::

link::Guides/ATK-Glossary::

link::Overviews/ABCs-Guides-Toots::



section:: Further reading
